'use strict'

var Module = { // eslint-disable-line
  cwrap: function () { return arguments[0] === 'version' ? version : compileStandard },
  writeStringToMemory: function () {},
  setValue: function () {},
  Pointer_stringify: function (value) { return value },
  Runtime: {
    addFunction: function () { return arguments[0] },
    removeFunction: function () {}
  },
  _compileJSONMulti: {},
  _compileJSONCallback: {},
  _compileJSON: {},
  _malloc: function () {},
  _compileStandard: compileStandard
}

function compileStandard (source, missingInputs) {
  source = source.replace(/(\t)|(\n)|(\\n)|( )/g, '')
  var data = mockData[source] // eslint-disable-line
  if (data === undefined) {
    return JSON.stringify({
      errors: [{ formattedMessage: 'mock compiler: source not found', severity: 'error' }]
    })
  } else {
    data.missingInputs.map(function (item, i) {
      if (missingInputs) {
        missingInputs(item, '', '')
      }
    })
  }
  return data.result
}

function version () {
  return mockCompilerVersion // eslint-disable-line
}


var mockCompilerVersion = '0.6.1+commit.e6f7d5a4.Emscripten.clang'

var mockData = {"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"pragma solidity >=0.4.22 <0.7.0;\\n\\n/** \\n * @title Ballot\\n * @dev Implements voting process along with vote delegation\\n */\\ncontract Ballot {\\n   \\n    struct Voter {\\n        uint weight; // weight is accumulated by delegation\\n        bool voted;  // if true, that person already voted\\n        address delegate; // person delegated to\\n        uint vote;   // index of the voted proposal\\n    }\\n\\n    struct Proposal {\\n        // If you can limit the length to a certain number of bytes, \\n        // always use one of bytes1 to bytes32 because they are much cheaper\\n        bytes32 name;   // short name (up to 32 bytes)\\n        uint voteCount; // number of accumulated votes\\n    }\\n\\n    address public chairperson;\\n\\n    mapping(address => Voter) public voters;\\n\\n    Proposal[] public proposals;\\n\\n    /** \\n     * @dev Create a new ballot to choose one of 'proposalNames'.\\n     * @param proposalNames names of proposals\\n     */\\n    constructor(bytes32[] memory proposalNames) public {\\n        chairperson = msg.sender;\\n        voters[chairperson].weight = 1;\\n\\n        for (uint i = 0; i < proposalNames.length; i++) {\\n            // 'Proposal({...})' creates a temporary\\n            // Proposal object and 'proposals.push(...)'\\n            // appends it to the end of 'proposals'.\\n            proposals.push(Proposal({\\n                name: proposalNames[i],\\n                voteCount: 0\\n            }));\\n        }\\n    }\\n    \\n    /** \\n     * @dev Give 'voter' the right to vote on this ballot. May only be called by 'chairperson'.\\n     * @param voter address of voter\\n     */\\n    function giveRightToVote(address voter) public {\\n        require(\\n            msg.sender == chairperson,\\n            \\\"Only chairperson can give right to vote.\\\"\\n        );\\n        require(\\n            !voters[voter].voted,\\n            \\\"The voter already voted.\\\"\\n        );\\n        require(voters[voter].weight == 0);\\n        voters[voter].weight = 1;\\n    }\\n\\n    /**\\n     * @dev Delegate your vote to the voter 'to'.\\n     * @param to address to which vote is delegated\\n     */\\n    function delegate(address to) public {\\n        Voter storage sender = voters[msg.sender];\\n        require(!sender.voted, \\\"You already voted.\\\");\\n        require(to != msg.sender, \\\"Self-delegation is disallowed.\\\");\\n\\n        while (voters[to].delegate != address(0)) {\\n            to = voters[to].delegate;\\n\\n            // We found a loop in the delegation, not allowed.\\n            require(to != msg.sender, \\\"Found loop in delegation.\\\");\\n        }\\n        sender.voted = true;\\n        sender.delegate = to;\\n        Voter storage delegate_ = voters[to];\\n        if (delegate_.voted) {\\n            // If the delegate already voted,\\n            // directly add to the number of votes\\n            proposals[delegate_.vote].voteCount += sender.weight;\\n        } else {\\n            // If the delegate did not vote yet,\\n            // add to her weight.\\n            delegate_.weight += sender.weight;\\n        }\\n    }\\n\\n    /**\\n     * @dev Give your vote (including votes delegated to you) to proposal 'proposals[proposal].name'.\\n     * @param proposal index of proposal in the proposals array\\n     */\\n    function vote(uint proposal) public {\\n        Voter storage sender = voters[msg.sender];\\n        require(sender.weight != 0, \\\"Has no right to vote\\\");\\n        require(!sender.voted, \\\"Already voted.\\\");\\n        sender.voted = true;\\n        sender.vote = proposal;\\n\\n        // If 'proposal' is out of the range of the array,\\n        // this will throw automatically and revert all\\n        // changes.\\n        proposals[proposal].voteCount += sender.weight;\\n    }\\n\\n    /** \\n     * @dev Computes the winning proposal taking all previous votes into account.\\n     * @return winningProposal_ index of winning proposal in the proposals array\\n     */\\n    function winningProposal() public view\\n            returns (uint winningProposal_)\\n    {\\n        uint winningVoteCount = 0;\\n        for (uint p = 0; p < proposals.length; p++) {\\n            if (proposals[p].voteCount > winningVoteCount) {\\n                winningVoteCount = proposals[p].voteCount;\\n                winningProposal_ = p;\\n            }\\n        }\\n    }\\n\\n    /** \\n     * @dev Calls winningProposal() function to get the index of the winner contained in the proposals array and then\\n     * @return winnerName_ the name of the winner\\n     */\\n    function winnerName() public view\\n            returns (bytes32 winnerName_)\\n    {\\n        winnerName_ = proposals[winningProposal()].name;\\n    }\\n}\\n\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"pragma solidity >=0.4.22 <0.7.0;\\n\\n/** \\n * @title Ballot\\n * @dev Implements voting process along with vote delegation\\n */\\ncontract Ballot {\\n   \\n    struct Voter {\\n        uint weight; // weight is accumulated by delegation\\n        bool voted;  // if true, that person already voted\\n        address delegate; // person delegated to\\n        uint vote;   // index of the voted proposal\\n    }\\n\\n    struct Proposal {\\n        // If you can limit the length to a certain number of bytes, \\n        // always use one of bytes1 to bytes32 because they are much cheaper\\n        bytes32 name;   // short name (up to 32 bytes)\\n        uint voteCount; // number of accumulated votes\\n    }\\n\\n    address public chairperson;\\n\\n    mapping(address => Voter) public voters;\\n\\n    Proposal[] public proposals;\\n\\n    /** \\n     * @dev Create a new ballot to choose one of 'proposalNames'.\\n     * @param proposalNames names of proposals\\n     */\\n    constructor(bytes32[] memory proposalNames) public {\\n        chairperson = msg.sender;\\n        voters[chairperson].weight = 1;\\n\\n        for (uint i = 0; i < proposalNames.length; i++) {\\n            // 'Proposal({...})' creates a temporary\\n            // Proposal object and 'proposals.push(...)'\\n            // appends it to the end of 'proposals'.\\n            proposals.push(Proposal({\\n                name: proposalNames[i],\\n                voteCount: 0\\n            }));\\n        }\\n    }\\n    \\n    /** \\n     * @dev Give 'voter' the right to vote on this ballot. May only be called by 'chairperson'.\\n     * @param voter address of voter\\n     */\\n    function giveRightToVote(address voter) public {\\n        require(\\n            msg.sender == chairperson,\\n            \\\"Only chairperson can give right to vote.\\\"\\n        );\\n        require(\\n            !voters[voter].voted,\\n            \\\"The voter already voted.\\\"\\n        );\\n        require(voters[voter].weight == 0);\\n        voters[voter].weight = 1;\\n    }\\n\\n    /**\\n     * @dev Delegate your vote to the voter 'to'.\\n     * @param to address to which vote is delegated\\n     */\\n    function delegate(address to) public {\\n        Voter storage sender = voters[msg.sender];\\n        require(!sender.voted, \\\"You already voted.\\\");\\n        require(to != msg.sender, \\\"Self-delegation is disallowed.\\\");\\n\\n        while (voters[to].delegate != address(0)) {\\n            to = voters[to].delegate;\\n\\n            // We found a loop in the delegation, not allowed.\\n            require(to != msg.sender, \\\"Found loop in delegation.\\\");\\n        }\\n        sender.voted = true;\\n        sender.delegate = to;\\n        Voter storage delegate_ = voters[to];\\n        if (delegate_.voted) {\\n            // If the delegate already voted,\\n            // directly add to the number of votes\\n            proposals[delegate_.vote].voteCount += sender.weight;\\n        } else {\\n            // If the delegate did not vote yet,\\n            // add to her weight.\\n            delegate_.weight += sender.weight;\\n        }\\n    }\\n\\n    /**\\n     * @dev Give your vote (including votes delegated to you) to proposal 'proposals[proposal].name'.\\n     * @param proposal index of proposal in the proposals array\\n     */\\n    function vote(uint proposal) public {\\n        Voter storage sender = voters[msg.sender];\\n        require(sender.weight != 0, \\\"Has no right to vote\\\");\\n        require(!sender.voted, \\\"Already voted.\\\");\\n        sender.voted = true;\\n        sender.vote = proposal;\\n\\n        // If 'proposal' is out of the range of the array,\\n        // this will throw automatically and revert all\\n        // changes.\\n        proposals[proposal].voteCount += sender.weight;\\n    }\\n\\n    /** \\n     * @dev Computes the winning proposal taking all previous votes into account.\\n     * @return winningProposal_ index of winning proposal in the proposals array\\n     */\\n    function winningProposal() public view\\n            returns (uint winningProposal_)\\n    {\\n        uint winningVoteCount = 0;\\n        for (uint p = 0; p < proposals.length; p++) {\\n            if (proposals[p].voteCount > winningVoteCount) {\\n                winningVoteCount = proposals[p].voteCount;\\n                winningProposal_ = p;\\n            }\\n        }\\n    }\\n\\n    /** \\n     * @dev Calls winningProposal() function to get the index of the winner contained in the proposals array and then\\n     * @return winnerName_ the name of the winner\\n     */\\n    function winnerName() public view\\n            returns (bytes32 winnerName_)\\n    {\\n        winnerName_ = proposals[winningProposal()].name;\\n    }\\n}\\n\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled.sol":{"content":"pragma solidity >=0.4.22 <0.7.0;\n\n/** \n * @title Ballot\n * @dev Implements voting process along with vote delegation\n */\ncontract Ballot {\n   \n    struct Voter {\n        uint weight; // weight is accumulated by delegation\n        bool voted;  // if true, that person already voted\n        address delegate; // person delegated to\n        uint vote;   // index of the voted proposal\n    }\n\n    struct Proposal {\n        // If you can limit the length to a certain number of bytes, \n        // always use one of bytes1 to bytes32 because they are much cheaper\n        bytes32 name;   // short name (up to 32 bytes)\n        uint voteCount; // number of accumulated votes\n    }\n\n    address public chairperson;\n\n    mapping(address => Voter) public voters;\n\n    Proposal[] public proposals;\n\n    /** \n     * @dev Create a new ballot to choose one of 'proposalNames'.\n     * @param proposalNames names of proposals\n     */\n    constructor(bytes32[] memory proposalNames) public {\n        chairperson = msg.sender;\n        voters[chairperson].weight = 1;\n\n        for (uint i = 0; i < proposalNames.length; i++) {\n            // 'Proposal({...})' creates a temporary\n            // Proposal object and 'proposals.push(...)'\n            // appends it to the end of 'proposals'.\n            proposals.push(Proposal({\n                name: proposalNames[i],\n                voteCount: 0\n            }));\n        }\n    }\n    \n    /** \n     * @dev Give 'voter' the right to vote on this ballot. May only be called by 'chairperson'.\n     * @param voter address of voter\n     */\n    function giveRightToVote(address voter) public {\n        require(\n            msg.sender == chairperson,\n            \"Only chairperson can give right to vote.\"\n        );\n        require(\n            !voters[voter].voted,\n            \"The voter already voted.\"\n        );\n        require(voters[voter].weight == 0);\n        voters[voter].weight = 1;\n    }\n\n    /**\n     * @dev Delegate your vote to the voter 'to'.\n     * @param to address to which vote is delegated\n     */\n    function delegate(address to) public {\n        Voter storage sender = voters[msg.sender];\n        require(!sender.voted, \"You already voted.\");\n        require(to != msg.sender, \"Self-delegation is disallowed.\");\n\n        while (voters[to].delegate != address(0)) {\n            to = voters[to].delegate;\n\n            // We found a loop in the delegation, not allowed.\n            require(to != msg.sender, \"Found loop in delegation.\");\n        }\n        sender.voted = true;\n        sender.delegate = to;\n        Voter storage delegate_ = voters[to];\n        if (delegate_.voted) {\n            // If the delegate already voted,\n            // directly add to the number of votes\n            proposals[delegate_.vote].voteCount += sender.weight;\n        } else {\n            // If the delegate did not vote yet,\n            // add to her weight.\n            delegate_.weight += sender.weight;\n        }\n    }\n\n    /**\n     * @dev Give your vote (including votes delegated to you) to proposal 'proposals[proposal].name'.\n     * @param proposal index of proposal in the proposals array\n     */\n    function vote(uint proposal) public {\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"Has no right to vote\");\n        require(!sender.voted, \"Already voted.\");\n        sender.voted = true;\n        sender.vote = proposal;\n\n        // If 'proposal' is out of the range of the array,\n        // this will throw automatically and revert all\n        // changes.\n        proposals[proposal].voteCount += sender.weight;\n    }\n\n    /** \n     * @dev Computes the winning proposal taking all previous votes into account.\n     * @return winningProposal_ index of winning proposal in the proposals array\n     */\n    function winningProposal() public view\n            returns (uint winningProposal_)\n    {\n        uint winningVoteCount = 0;\n        for (uint p = 0; p < proposals.length; p++) {\n            if (proposals[p].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }\n    }\n\n    /** \n     * @dev Calls winningProposal() function to get the index of the winner contained in the proposals array and then\n     * @return winnerName_ the name of the winner\n     */\n    function winnerName() public view\n            returns (bytes32 winnerName_)\n    {\n        winnerName_ = proposals[winningProposal()].name;\n    }\n}\n"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"pragma solidity >=0.4.22 <0.7.0;\\n\\n/** \\n * @title Ballot\\n * @dev Implements voting process along with vote delegation\\n */\\ncontract Ballot {\\n   \\n    struct Voter {\\n        uint weight; // weight is accumulated by delegation\\n        bool voted;  // if true, that person already voted\\n        address delegate; // person delegated to\\n        uint vote;   // index of the voted proposal\\n    }\\n\\n    struct Proposal {\\n        // If you can limit the length to a certain number of bytes, \\n        // always use one of bytes1 to bytes32 because they are much cheaper\\n        bytes32 name;   // short name (up to 32 bytes)\\n        uint voteCount; // number of accumulated votes\\n    }\\n\\n    address public chairperson;\\n\\n    mapping(address => Voter) public voters;\\n\\n    Proposal[] public proposals;\\n\\n    /** \\n     * @dev Create a new ballot to choose one of 'proposalNames'.\\n     * @param proposalNames names of proposals\\n     */\\n    constructor(bytes32[] memory proposalNames) public {\\n        chairperson = msg.sender;\\n        voters[chairperson].weight = 1;\\n\\n        for (uint i = 0; i < proposalNames.length; i++) {\\n            // 'Proposal({...})' creates a temporary\\n            // Proposal object and 'proposals.push(...)'\\n            // appends it to the end of 'proposals'.\\n            proposals.push(Proposal({\\n                name: proposalNames[i],\\n                voteCount: 0\\n            }));\\n        }\\n    }\\n    \\n    /** \\n     * @dev Give 'voter' the right to vote on this ballot. May only be called by 'chairperson'.\\n     * @param voter address of voter\\n     */\\n    function giveRightToVote(address voter) public {\\n        require(\\n            msg.sender == chairperson,\\n            \\\"Only chairperson can give right to vote.\\\"\\n        );\\n        require(\\n            !voters[voter].voted,\\n            \\\"The voter already voted.\\\"\\n        );\\n        require(voters[voter].weight == 0);\\n        voters[voter].weight = 1;\\n    }\\n\\n    /**\\n     * @dev Delegate your vote to the voter 'to'.\\n     * @param to address to which vote is delegated\\n     */\\n    function delegate(address to) public {\\n        Voter storage sender = voters[msg.sender];\\n        require(!sender.voted, \\\"You already voted.\\\");\\n        require(to != msg.sender, \\\"Self-delegation is disallowed.\\\");\\n\\n        while (voters[to].delegate != address(0)) {\\n            to = voters[to].delegate;\\n\\n            // We found a loop in the delegation, not allowed.\\n            require(to != msg.sender, \\\"Found loop in delegation.\\\");\\n        }\\n        sender.voted = true;\\n        sender.delegate = to;\\n        Voter storage delegate_ = voters[to];\\n        if (delegate_.voted) {\\n            // If the delegate already voted,\\n            // directly add to the number of votes\\n            proposals[delegate_.vote].voteCount += sender.weight;\\n        } else {\\n            // If the delegate did not vote yet,\\n            // add to her weight.\\n            delegate_.weight += sender.weight;\\n        }\\n    }\\n\\n    /**\\n     * @dev Give your vote (including votes delegated to you) to proposal 'proposals[proposal].name'.\\n     * @param proposal index of proposal in the proposals array\\n     */\\n    function vote(uint proposal) public {\\n        Voter storage sender = voters[msg.sender];\\n        require(sender.weight != 0, \\\"Has no right to vote\\\");\\n        require(!sender.voted, \\\"Already voted.\\\");\\n        sender.voted = true;\\n        sender.vote = proposal;\\n\\n        // If 'proposal' is out of the range of the array,\\n        // this will throw automatically and revert all\\n        // changes.\\n        proposals[proposal].voteCount += sender.weight;\\n    }\\n\\n    /** \\n     * @dev Computes the winning proposal taking all previous votes into account.\\n     * @return winningProposal_ index of winning proposal in the proposals array\\n     */\\n    function winningProposal() public view\\n            returns (uint winningProposal_)\\n    {\\n        uint winningVoteCount = 0;\\n        for (uint p = 0; p < proposals.length; p++) {\\n            if (proposals[p].voteCount > winningVoteCount) {\\n                winningVoteCount = proposals[p].voteCount;\\n                winningProposal_ = p;\\n            }\\n        }\\n    }\\n\\n    /** \\n     * @dev Calls winningProposal() function to get the index of the winner contained in the proposals array and then\\n     * @return winnerName_ the name of the winner\\n     */\\n    function winnerName() public view\\n            returns (bytes32 winnerName_)\\n    {\\n        winnerName_ = proposals[winningProposal()].name;\\n    }\\n}\\n\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"pragma solidity >=0.4.22 <0.7.0;\\n\\n/** \\n * @title Ballot\\n * @dev Implements voting process along with vote delegation\\n */\\ncontract Ballot {\\n   \\n    struct Voter {\\n        uint weight; // weight is accumulated by delegation\\n        bool voted;  // if true, that person already voted\\n        address delegate; // person delegated to\\n        uint vote;   // index of the voted proposal\\n    }\\n\\n    struct Proposal {\\n        // If you can limit the length to a certain number of bytes, \\n        // always use one of bytes1 to bytes32 because they are much cheaper\\n        bytes32 name;   // short name (up to 32 bytes)\\n        uint voteCount; // number of accumulated votes\\n    }\\n\\n    address public chairperson;\\n\\n    mapping(address => Voter) public voters;\\n\\n    Proposal[] public proposals;\\n\\n    /** \\n     * @dev Create a new ballot to choose one of 'proposalNames'.\\n     * @param proposalNames names of proposals\\n     */\\n    constructor(bytes32[] memory proposalNames) public {\\n        chairperson = msg.sender;\\n        voters[chairperson].weight = 1;\\n\\n        for (uint i = 0; i < proposalNames.length; i++) {\\n            // 'Proposal({...})' creates a temporary\\n            // Proposal object and 'proposals.push(...)'\\n            // appends it to the end of 'proposals'.\\n            proposals.push(Proposal({\\n                name: proposalNames[i],\\n                voteCount: 0\\n            }));\\n        }\\n    }\\n    \\n    /** \\n     * @dev Give 'voter' the right to vote on this ballot. May only be called by 'chairperson'.\\n     * @param voter address of voter\\n     */\\n    function giveRightToVote(address voter) public {\\n        require(\\n            msg.sender == chairperson,\\n            \\\"Only chairperson can give right to vote.\\\"\\n        );\\n        require(\\n            !voters[voter].voted,\\n            \\\"The voter already voted.\\\"\\n        );\\n        require(voters[voter].weight == 0);\\n        voters[voter].weight = 1;\\n    }\\n\\n    /**\\n     * @dev Delegate your vote to the voter 'to'.\\n     * @param to address to which vote is delegated\\n     */\\n    function delegate(address to) public {\\n        Voter storage sender = voters[msg.sender];\\n        require(!sender.voted, \\\"You already voted.\\\");\\n        require(to != msg.sender, \\\"Self-delegation is disallowed.\\\");\\n\\n        while (voters[to].delegate != address(0)) {\\n            to = voters[to].delegate;\\n\\n            // We found a loop in the delegation, not allowed.\\n            require(to != msg.sender, \\\"Found loop in delegation.\\\");\\n        }\\n        sender.voted = true;\\n        sender.delegate = to;\\n        Voter storage delegate_ = voters[to];\\n        if (delegate_.voted) {\\n            // If the delegate already voted,\\n            // directly add to the number of votes\\n            proposals[delegate_.vote].voteCount += sender.weight;\\n        } else {\\n            // If the delegate did not vote yet,\\n            // add to her weight.\\n            delegate_.weight += sender.weight;\\n        }\\n    }\\n\\n    /**\\n     * @dev Give your vote (including votes delegated to you) to proposal 'proposals[proposal].name'.\\n     * @param proposal index of proposal in the proposals array\\n     */\\n    function vote(uint proposal) public {\\n        Voter storage sender = voters[msg.sender];\\n        require(sender.weight != 0, \\\"Has no right to vote\\\");\\n        require(!sender.voted, \\\"Already voted.\\\");\\n        sender.voted = true;\\n        sender.vote = proposal;\\n\\n        // If 'proposal' is out of the range of the array,\\n        // this will throw automatically and revert all\\n        // changes.\\n        proposals[proposal].voteCount += sender.weight;\\n    }\\n\\n    /** \\n     * @dev Computes the winning proposal taking all previous votes into account.\\n     * @return winningProposal_ index of winning proposal in the proposals array\\n     */\\n    function winningProposal() public view\\n            returns (uint winningProposal_)\\n    {\\n        uint winningVoteCount = 0;\\n        for (uint p = 0; p < proposals.length; p++) {\\n            if (proposals[p].voteCount > winningVoteCount) {\\n                winningVoteCount = proposals[p].voteCount;\\n                winningProposal_ = p;\\n            }\\n        }\\n    }\\n\\n    /** \\n     * @dev Calls winningProposal() function to get the index of the winner contained in the proposals array and then\\n     * @return winnerName_ the name of the winner\\n     */\\n    function winnerName() public view\\n            returns (bytes32 winnerName_)\\n    {\\n        winnerName_ = proposals[winningProposal()].name;\\n    }\\n}\\n\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled.sol":{"content":"pragma solidity >=0.4.22 <0.7.0;\n\n/** \n * @title Ballot\n * @dev Implements voting process along with vote delegation\n */\ncontract Ballot {\n   \n    struct Voter {\n        uint weight; // weight is accumulated by delegation\n        bool voted;  // if true, that person already voted\n        address delegate; // person delegated to\n        uint vote;   // index of the voted proposal\n    }\n\n    struct Proposal {\n        // If you can limit the length to a certain number of bytes, \n        // always use one of bytes1 to bytes32 because they are much cheaper\n        bytes32 name;   // short name (up to 32 bytes)\n        uint voteCount; // number of accumulated votes\n    }\n\n    address public chairperson;\n\n    mapping(address => Voter) public voters;\n\n    Proposal[] public proposals;\n\n    /** \n     * @dev Create a new ballot to choose one of 'proposalNames'.\n     * @param proposalNames names of proposals\n     */\n    constructor(bytes32[] memory proposalNames) public {\n        chairperson = msg.sender;\n        voters[chairperson].weight = 1;\n\n        for (uint i = 0; i < proposalNames.length; i++) {\n            // 'Proposal({...})' creates a temporary\n            // Proposal object and 'proposals.push(...)'\n            // appends it to the end of 'proposals'.\n            proposals.push(Proposal({\n                name: proposalNames[i],\n                voteCount: 0\n            }));\n        }\n    }\n    \n    /** \n     * @dev Give 'voter' the right to vote on this ballot. May only be called by 'chairperson'.\n     * @param voter address of voter\n     */\n    function giveRightToVote(address voter) public {\n        require(\n            msg.sender == chairperson,\n            \"Only chairperson can give right to vote.\"\n        );\n        require(\n            !voters[voter].voted,\n            \"The voter already voted.\"\n        );\n        require(voters[voter].weight == 0);\n        voters[voter].weight = 1;\n    }\n\n    /**\n     * @dev Delegate your vote to the voter 'to'.\n     * @param to address to which vote is delegated\n     */\n    function delegate(address to) public {\n        Voter storage sender = voters[msg.sender];\n        require(!sender.voted, \"You already voted.\");\n        require(to != msg.sender, \"Self-delegation is disallowed.\");\n\n        while (voters[to].delegate != address(0)) {\n            to = voters[to].delegate;\n\n            // We found a loop in the delegation, not allowed.\n            require(to != msg.sender, \"Found loop in delegation.\");\n        }\n        sender.voted = true;\n        sender.delegate = to;\n        Voter storage delegate_ = voters[to];\n        if (delegate_.voted) {\n            // If the delegate already voted,\n            // directly add to the number of votes\n            proposals[delegate_.vote].voteCount += sender.weight;\n        } else {\n            // If the delegate did not vote yet,\n            // add to her weight.\n            delegate_.weight += sender.weight;\n        }\n    }\n\n    /**\n     * @dev Give your vote (including votes delegated to you) to proposal 'proposals[proposal].name'.\n     * @param proposal index of proposal in the proposals array\n     */\n    function vote(uint proposal) public {\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"Has no right to vote\");\n        require(!sender.voted, \"Already voted.\");\n        sender.voted = true;\n        sender.vote = proposal;\n\n        // If 'proposal' is out of the range of the array,\n        // this will throw automatically and revert all\n        // changes.\n        proposals[proposal].voteCount += sender.weight;\n    }\n\n    /** \n     * @dev Computes the winning proposal taking all previous votes into account.\n     * @return winningProposal_ index of winning proposal in the proposals array\n     */\n    function winningProposal() public view\n            returns (uint winningProposal_)\n    {\n        uint winningVoteCount = 0;\n        for (uint p = 0; p < proposals.length; p++) {\n            if (proposals[p].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }\n    }\n\n    /** \n     * @dev Calls winningProposal() function to get the index of the winner contained in the proposals array and then\n     * @return winnerName_ the name of the winner\n     */\n    function winnerName() public view\n            returns (bytes32 winnerName_)\n    {\n        winnerName_ = proposals[winningProposal()].name;\n    }\n}\n"}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled5.sol\":{\"content\":\"library lib {\\n      function getInt () public view returns (uint) {\\n          return 45;\\n      }\\n    }\\n\\n    contract test {\\n      function get () public view returns (uint) {\\n          return lib.getInt();\\n      }\\n    }\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled5.sol\":{\"content\":\"library lib {\\n      function getInt () public view returns (uint) {\\n          return 45;\\n      }\\n    }\\n\\n    contract test {\\n      function get () public view returns (uint) {\\n          return lib.getInt();\\n      }\\n    }\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled5.sol":{"content":"library lib {\n      function getInt () public view returns (uint) {\n          return 45;\n      }\n    }\n\n    contract test {\n      function get () public view returns (uint) {\n          return lib.getInt();\n      }\n    }"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled5.sol\":{\"content\":\"library lib {\\n      function getInt () public view returns (uint) {\\n          return 45;\\n      }\\n    }\\n\\n    contract test {\\n      function get () public view returns (uint) {\\n          return lib.getInt();\\n      }\\n    }\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled5.sol\":{\"content\":\"library lib {\\n      function getInt () public view returns (uint) {\\n          return 45;\\n      }\\n    }\\n\\n    contract test {\\n      function get () public view returns (uint) {\\n          return lib.getInt();\\n      }\\n    }\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled5.sol":{"content":"library lib {\n      function getInt () public view returns (uint) {\n          return 45;\n      }\n    }\n\n    contract test {\n      function get () public view returns (uint) {\n          return lib.getInt();\n      }\n    }"}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/testRecorder.sol\":{\"content\":\"contract testRecorder {\\n  constructor(uint p) public {\\n      \\n  }\\n  function set (uint _p) public {\\n          \\n  }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/testRecorder.sol\":{\"content\":\"contract testRecorder {\\n  constructor(uint p) public {\\n      \\n  }\\n  function set (uint _p) public {\\n          \\n  }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/testRecorder.sol":{"content":"contract testRecorder {\n  constructor(uint p) public {\n      \n  }\n  function set (uint _p) public {\n          \n  }\n}"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/testRecorder.sol\":{\"content\":\"contract testRecorder {\\n  constructor(uint p) public {\\n      \\n  }\\n  function set (uint _p) public {\\n          \\n  }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/testRecorder.sol\":{\"content\":\"contract testRecorder {\\n  constructor(uint p) public {\\n      \\n  }\\n  function set (uint _p) public {\\n          \\n  }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/testRecorder.sol":{"content":"contract testRecorder {\n  constructor(uint p) public {\n      \n  }\n  function set (uint _p) public {\n          \n  }\n}"}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"localhost/folder1/contract2.sol\":{\"content\":\"contract test2 { function get () public returns (uint) { return 11; }}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"localhost/folder1/contract2.sol\":{\"content\":\"contract test2 { function get () public returns (uint) { return 11; }}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"localhost/folder1/contract2.sol":{"content":"contract test2 { function get () public returns (uint) { return 11; }}"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"localhost/folder1/contract2.sol\":{\"content\":\"contract test2 { function get () public returns (uint) { return 11; }}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"localhost/folder1/contract2.sol\":{\"content\":\"contract test2 { function get () public returns (uint) { return 11; }}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"localhost/folder1/contract2.sol":{"content":"contract test2 { function get () public returns (uint) { return 11; }}"}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"localhost/src/gmbh/company.sol\":{\"content\":\"import \\\"./contract.sol\\\";\\ncontract Assets {\\n    uint[] proposals;\\n    function add(uint8 _numProposals) public {\\n        proposals.length = _numProposals;\\n    }\\n}\\n\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"localhost/src/gmbh/company.sol\":{\"content\":\"import \\\"./contract.sol\\\";\\ncontract Assets {\\n    uint[] proposals;\\n    function add(uint8 _numProposals) public {\\n        proposals.length = _numProposals;\\n    }\\n}\\n\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"localhost/src/gmbh/company.sol":{"content":"import \"./contract.sol\";\ncontract Assets {\n    uint[] proposals;\n    function add(uint8 _numProposals) public {\n        proposals.length = _numProposals;\n    }\n}\n"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"localhost/src/gmbh/company.sol\":{\"content\":\"import \\\"./contract.sol\\\";\\ncontract Assets {\\n    uint[] proposals;\\n    function add(uint8 _numProposals) public {\\n        proposals.length = _numProposals;\\n    }\\n}\\n\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"localhost/src/gmbh/company.sol\":{\"content\":\"import \\\"./contract.sol\\\";\\ncontract Assets {\\n    uint[] proposals;\\n    function add(uint8 _numProposals) public {\\n        proposals.length = _numProposals;\\n    }\\n}\\n\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"localhost/src/gmbh/company.sol":{"content":"import \"./contract.sol\";\ncontract Assets {\n    uint[] proposals;\n    function add(uint8 _numProposals) public {\n        proposals.length = _numProposals;\n    }\n}\n"}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"localhost/src/gmbh/company.sol\":{\"content\":\"import \\\"./contract.sol\\\";\\ncontract Assets {\\n    uint[] proposals;\\n    function add(uint8 _numProposals) public {\\n        proposals.length = _numProposals;\\n    }\\n}\\n\"},\"localhost/src/gmbh/contract.sol\":{\"content\":\"contract gmbh {\\n    uint[] proposals;\\n    function register(uint8 _numProposals) public {\\n        proposals.length = _numProposals;\\n    }\\n}\\n\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"localhost/src/gmbh/company.sol\":{\"content\":\"import \\\"./contract.sol\\\";\\ncontract Assets {\\n    uint[] proposals;\\n    function add(uint8 _numProposals) public {\\n        proposals.length = _numProposals;\\n    }\\n}\\n\"},\"localhost/src/gmbh/contract.sol\":{\"content\":\"contract gmbh {\\n    uint[] proposals;\\n    function register(uint8 _numProposals) public {\\n        proposals.length = _numProposals;\\n    }\\n}\\n\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"localhost/src/gmbh/company.sol":{"content":"import \"./contract.sol\";\ncontract Assets {\n    uint[] proposals;\n    function add(uint8 _numProposals) public {\n        proposals.length = _numProposals;\n    }\n}\n"},"localhost/src/gmbh/contract.sol":{"content":"contract gmbh {\n    uint[] proposals;\n    function register(uint8 _numProposals) public {\n        proposals.length = _numProposals;\n    }\n}\n"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"localhost/src/gmbh/company.sol\":{\"content\":\"import \\\"./contract.sol\\\";\\ncontract Assets {\\n    uint[] proposals;\\n    function add(uint8 _numProposals) public {\\n        proposals.length = _numProposals;\\n    }\\n}\\n\"},\"localhost/src/gmbh/contract.sol\":{\"content\":\"contract gmbh {\\n    uint[] proposals;\\n    function register(uint8 _numProposals) public {\\n        proposals.length = _numProposals;\\n    }\\n}\\n\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"localhost/src/gmbh/company.sol\":{\"content\":\"import \\\"./contract.sol\\\";\\ncontract Assets {\\n    uint[] proposals;\\n    function add(uint8 _numProposals) public {\\n        proposals.length = _numProposals;\\n    }\\n}\\n\"},\"localhost/src/gmbh/contract.sol\":{\"content\":\"contract gmbh {\\n    uint[] proposals;\\n    function register(uint8 _numProposals) public {\\n        proposals.length = _numProposals;\\n    }\\n}\\n\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"localhost/src/gmbh/company.sol":{"content":"import \"./contract.sol\";\ncontract Assets {\n    uint[] proposals;\n    function add(uint8 _numProposals) public {\n        proposals.length = _numProposals;\n    }\n}\n"},"localhost/src/gmbh/contract.sol":{"content":"contract gmbh {\n    uint[] proposals;\n    function register(uint8 _numProposals) public {\n        proposals.length = _numProposals;\n    }\n}\n"}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/signMassage.sol\":{\"content\":\"\\n    pragma solidity >=0.4.22 <0.7.0;\\n    contract SignMassageTest {\\n      function testRecovery(bytes32 h, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {\\n          return ecrecover(h, v, r, s);\\n      }\\n    }\\n\\n    library ECVerify {\\n      function ecrecovery(bytes32 hash, bytes memory sig) public pure returns (address) {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        if (sig.length != 65) {\\n          return address(0);\\n        }\\n\\n        assembly {\\n          r := mload(add(sig, 32))\\n          s := mload(add(sig, 64))\\n          v := and(mload(add(sig, 65)), 255)\\n        }\\n\\n        if (v < 27) {\\n          v += 27;\\n        }\\n\\n        if (v != 27 && v != 28) {\\n          return address(0);\\n        }\\n\\n        return ecrecover(hash, v, r, s);\\n      }\\n\\n      function ecverify(bytes32 hash, bytes memory sig, address signer) public pure returns (bool) {\\n        return signer == ecrecovery(hash, sig);\\n      }\\n    }\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/signMassage.sol\":{\"content\":\"\\n    pragma solidity >=0.4.22 <0.7.0;\\n    contract SignMassageTest {\\n      function testRecovery(bytes32 h, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {\\n          return ecrecover(h, v, r, s);\\n      }\\n    }\\n\\n    library ECVerify {\\n      function ecrecovery(bytes32 hash, bytes memory sig) public pure returns (address) {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        if (sig.length != 65) {\\n          return address(0);\\n        }\\n\\n        assembly {\\n          r := mload(add(sig, 32))\\n          s := mload(add(sig, 64))\\n          v := and(mload(add(sig, 65)), 255)\\n        }\\n\\n        if (v < 27) {\\n          v += 27;\\n        }\\n\\n        if (v != 27 && v != 28) {\\n          return address(0);\\n        }\\n\\n        return ecrecover(hash, v, r, s);\\n      }\\n\\n      function ecverify(bytes32 hash, bytes memory sig, address signer) public pure returns (bool) {\\n        return signer == ecrecovery(hash, sig);\\n      }\\n    }\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/signMassage.sol":{"content":"\n    pragma solidity >=0.4.22 <0.7.0;\n    contract SignMassageTest {\n      function testRecovery(bytes32 h, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {\n          return ecrecover(h, v, r, s);\n      }\n    }\n\n    library ECVerify {\n      function ecrecovery(bytes32 hash, bytes memory sig) public pure returns (address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        if (sig.length != 65) {\n          return address(0);\n        }\n\n        assembly {\n          r := mload(add(sig, 32))\n          s := mload(add(sig, 64))\n          v := and(mload(add(sig, 65)), 255)\n        }\n\n        if (v < 27) {\n          v += 27;\n        }\n\n        if (v != 27 && v != 28) {\n          return address(0);\n        }\n\n        return ecrecover(hash, v, r, s);\n      }\n\n      function ecverify(bytes32 hash, bytes memory sig, address signer) public pure returns (bool) {\n        return signer == ecrecovery(hash, sig);\n      }\n    }"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/signMassage.sol\":{\"content\":\"\\n    pragma solidity >=0.4.22 <0.7.0;\\n    contract SignMassageTest {\\n      function testRecovery(bytes32 h, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {\\n          return ecrecover(h, v, r, s);\\n      }\\n    }\\n\\n    library ECVerify {\\n      function ecrecovery(bytes32 hash, bytes memory sig) public pure returns (address) {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        if (sig.length != 65) {\\n          return address(0);\\n        }\\n\\n        assembly {\\n          r := mload(add(sig, 32))\\n          s := mload(add(sig, 64))\\n          v := and(mload(add(sig, 65)), 255)\\n        }\\n\\n        if (v < 27) {\\n          v += 27;\\n        }\\n\\n        if (v != 27 && v != 28) {\\n          return address(0);\\n        }\\n\\n        return ecrecover(hash, v, r, s);\\n      }\\n\\n      function ecverify(bytes32 hash, bytes memory sig, address signer) public pure returns (bool) {\\n        return signer == ecrecovery(hash, sig);\\n      }\\n    }\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/signMassage.sol\":{\"content\":\"\\n    pragma solidity >=0.4.22 <0.7.0;\\n    contract SignMassageTest {\\n      function testRecovery(bytes32 h, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {\\n          return ecrecover(h, v, r, s);\\n      }\\n    }\\n\\n    library ECVerify {\\n      function ecrecovery(bytes32 hash, bytes memory sig) public pure returns (address) {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        if (sig.length != 65) {\\n          return address(0);\\n        }\\n\\n        assembly {\\n          r := mload(add(sig, 32))\\n          s := mload(add(sig, 64))\\n          v := and(mload(add(sig, 65)), 255)\\n        }\\n\\n        if (v < 27) {\\n          v += 27;\\n        }\\n\\n        if (v != 27 && v != 28) {\\n          return address(0);\\n        }\\n\\n        return ecrecover(hash, v, r, s);\\n      }\\n\\n      function ecverify(bytes32 hash, bytes memory sig, address signer) public pure returns (bool) {\\n        return signer == ecrecovery(hash, sig);\\n      }\\n    }\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/signMassage.sol":{"content":"\n    pragma solidity >=0.4.22 <0.7.0;\n    contract SignMassageTest {\n      function testRecovery(bytes32 h, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {\n          return ecrecover(h, v, r, s);\n      }\n    }\n\n    library ECVerify {\n      function ecrecovery(bytes32 hash, bytes memory sig) public pure returns (address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        if (sig.length != 65) {\n          return address(0);\n        }\n\n        assembly {\n          r := mload(add(sig, 32))\n          s := mload(add(sig, 64))\n          v := and(mload(add(sig, 65)), 255)\n        }\n\n        if (v < 27) {\n          v += 27;\n        }\n\n        if (v != 27 && v != 28) {\n          return address(0);\n        }\n\n        return ecrecover(hash, v, r, s);\n      }\n\n      function ecverify(bytes32 hash, bytes memory sig, address signer) public pure returns (bool) {\n        return signer == ecrecovery(hash, sig);\n      }\n    }"}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"contract test1 {} contract test2 {}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"contract test1 {} contract test2 {}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled.sol":{"content":"contract test1 {} contract test2 {}"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"contract test1 {} contract test2 {}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"contract test1 {} contract test2 {}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled.sol":{"content":"contract test1 {} contract test2 {}"}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled1.sol\":{\"content\":\"import \\\"./Untitled2.sol\\\"; contract test6 {}\"},\"browser/Untitled2.sol\":{\"content\":\"contract test4 {} contract test5 {}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled1.sol\":{\"content\":\"import \\\"./Untitled2.sol\\\"; contract test6 {}\"},\"browser/Untitled2.sol\":{\"content\":\"contract test4 {} contract test5 {}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled1.sol":{"content":"import \"./Untitled2.sol\"; contract test6 {}"},"browser/Untitled2.sol":{"content":"contract test4 {} contract test5 {}"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled1.sol\":{\"content\":\"import \\\"./Untitled2.sol\\\"; contract test6 {}\"},\"browser/Untitled2.sol\":{\"content\":\"contract test4 {} contract test5 {}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled1.sol\":{\"content\":\"import \\\"./Untitled2.sol\\\"; contract test6 {}\"},\"browser/Untitled2.sol\":{\"content\":\"contract test4 {} contract test5 {}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled1.sol":{"content":"import \"./Untitled2.sol\"; contract test6 {}"},"browser/Untitled2.sol":{"content":"contract test4 {} contract test5 {}"}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled3.sol\":{\"content\":\"import \\\"./Untitled11.sol\\\"; contract test6 {}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled3.sol\":{\"content\":\"import \\\"./Untitled11.sol\\\"; contract test6 {}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled3.sol":{"content":"import \"./Untitled11.sol\"; contract test6 {}"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled3.sol\":{\"content\":\"import \\\"./Untitled11.sol\\\"; contract test6 {}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled3.sol\":{\"content\":\"import \\\"./Untitled11.sol\\\"; contract test6 {}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled3.sol":{"content":"import \"./Untitled11.sol\"; contract test6 {}"}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled4.sol\":{\"content\":\"import \\\"github.com/ethereum/ens/contracts/ENS.sol\\\"; contract test7 {}\"},\"github.com/ethereum/ens/contracts/ENS.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\nimport './AbstractENS.sol';\\n\\n/**\\n * The ENS registry contract.\\n */\\ncontract ENS is AbstractENS {\\n  struct Record {\\n      address owner;\\n      address resolver;\\n      uint64 ttl;\\n  }\\n\\n  mapping(bytes32=>Record) records;\\n\\n  // Permits modifications only by the owner of the specified node.\\n  modifier only_owner(bytes32 node) {\\n      if (records[node].owner != msg.sender) revert();\\n      _;\\n  }\\n\\n  /**\\n   * Constructs a new ENS registrar.\\n   */\\n  constructor() public {\\n      records[0].owner = msg.sender;\\n  }\\n\\n  /**\\n   * Returns the address that owns the specified node.\\n   */\\n  function owner(bytes32 node) public view returns (address) {\\n      return records[node].owner;\\n  }\\n\\n  /**\\n   * Returns the address of the resolver for the specified node.\\n   */\\n  function resolver(bytes32 node) public view returns (address) {\\n      return records[node].resolver;\\n  }\\n\\n  /**\\n   * Returns the TTL of a node, and any records associated with it.\\n   */\\n  function ttl(bytes32 node) public view returns (uint64) {\\n      return records[node].ttl;\\n  }\\n\\n  /**\\n   * Transfers ownership of a node to a new address. May only be called by the current\\n   * owner of the node.\\n   * @param node The node to transfer ownership of.\\n   * @param owner The address of the new owner.\\n   */\\n  function setOwner(bytes32 node, address owner) public only_owner(node) {\\n      emit Transfer(node, owner);\\n      records[node].owner = owner;\\n  }\\n\\n  /**\\n   * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\\n   * called by the owner of the parent node.\\n   * @param node The parent node.\\n   * @param label The hash of the label specifying the subnode.\\n   * @param owner The address of the new owner.\\n   */\\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public only_owner(node) {\\n      bytes32 subnode = keccak256(abi.encodePacked(node, label));\\n      emit NewOwner(node, label, owner);\\n      records[subnode].owner = owner;\\n  }\\n\\n  /**\\n   * Sets the resolver address for the specified node.\\n   * @param node The node to update.\\n   * @param resolver The address of the resolver.\\n   */\\n  function setResolver(bytes32 node, address resolver) public only_owner(node) {\\n      emit NewResolver(node, resolver);\\n      records[node].resolver = resolver;\\n  }\\n\\n  /**\\n   * Sets the TTL for the specified node.\\n   * @param node The node to update.\\n   * @param ttl The TTL in seconds.\\n   */\\n  function setTTL(bytes32 node, uint64 ttl) public only_owner(node) {\\n      emit NewTTL(node, ttl);\\n      records[node].ttl = ttl;\\n  }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled4.sol\":{\"content\":\"import \\\"github.com/ethereum/ens/contracts/ENS.sol\\\"; contract test7 {}\"},\"github.com/ethereum/ens/contracts/ENS.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\nimport './AbstractENS.sol';\\n\\n/**\\n * The ENS registry contract.\\n */\\ncontract ENS is AbstractENS {\\n  struct Record {\\n      address owner;\\n      address resolver;\\n      uint64 ttl;\\n  }\\n\\n  mapping(bytes32=>Record) records;\\n\\n  // Permits modifications only by the owner of the specified node.\\n  modifier only_owner(bytes32 node) {\\n      if (records[node].owner != msg.sender) revert();\\n      _;\\n  }\\n\\n  /**\\n   * Constructs a new ENS registrar.\\n   */\\n  constructor() public {\\n      records[0].owner = msg.sender;\\n  }\\n\\n  /**\\n   * Returns the address that owns the specified node.\\n   */\\n  function owner(bytes32 node) public view returns (address) {\\n      return records[node].owner;\\n  }\\n\\n  /**\\n   * Returns the address of the resolver for the specified node.\\n   */\\n  function resolver(bytes32 node) public view returns (address) {\\n      return records[node].resolver;\\n  }\\n\\n  /**\\n   * Returns the TTL of a node, and any records associated with it.\\n   */\\n  function ttl(bytes32 node) public view returns (uint64) {\\n      return records[node].ttl;\\n  }\\n\\n  /**\\n   * Transfers ownership of a node to a new address. May only be called by the current\\n   * owner of the node.\\n   * @param node The node to transfer ownership of.\\n   * @param owner The address of the new owner.\\n   */\\n  function setOwner(bytes32 node, address owner) public only_owner(node) {\\n      emit Transfer(node, owner);\\n      records[node].owner = owner;\\n  }\\n\\n  /**\\n   * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\\n   * called by the owner of the parent node.\\n   * @param node The parent node.\\n   * @param label The hash of the label specifying the subnode.\\n   * @param owner The address of the new owner.\\n   */\\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public only_owner(node) {\\n      bytes32 subnode = keccak256(abi.encodePacked(node, label));\\n      emit NewOwner(node, label, owner);\\n      records[subnode].owner = owner;\\n  }\\n\\n  /**\\n   * Sets the resolver address for the specified node.\\n   * @param node The node to update.\\n   * @param resolver The address of the resolver.\\n   */\\n  function setResolver(bytes32 node, address resolver) public only_owner(node) {\\n      emit NewResolver(node, resolver);\\n      records[node].resolver = resolver;\\n  }\\n\\n  /**\\n   * Sets the TTL for the specified node.\\n   * @param node The node to update.\\n   * @param ttl The TTL in seconds.\\n   */\\n  function setTTL(bytes32 node, uint64 ttl) public only_owner(node) {\\n      emit NewTTL(node, ttl);\\n      records[node].ttl = ttl;\\n  }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled4.sol":{"content":"import \"github.com/ethereum/ens/contracts/ENS.sol\"; contract test7 {}"},"github.com/ethereum/ens/contracts/ENS.sol":{"content":"pragma solidity ^0.4.0;\n\nimport './AbstractENS.sol';\n\n/**\n * The ENS registry contract.\n */\ncontract ENS is AbstractENS {\n  struct Record {\n      address owner;\n      address resolver;\n      uint64 ttl;\n  }\n\n  mapping(bytes32=>Record) records;\n\n  // Permits modifications only by the owner of the specified node.\n  modifier only_owner(bytes32 node) {\n      if (records[node].owner != msg.sender) revert();\n      _;\n  }\n\n  /**\n   * Constructs a new ENS registrar.\n   */\n  constructor() public {\n      records[0].owner = msg.sender;\n  }\n\n  /**\n   * Returns the address that owns the specified node.\n   */\n  function owner(bytes32 node) public view returns (address) {\n      return records[node].owner;\n  }\n\n  /**\n   * Returns the address of the resolver for the specified node.\n   */\n  function resolver(bytes32 node) public view returns (address) {\n      return records[node].resolver;\n  }\n\n  /**\n   * Returns the TTL of a node, and any records associated with it.\n   */\n  function ttl(bytes32 node) public view returns (uint64) {\n      return records[node].ttl;\n  }\n\n  /**\n   * Transfers ownership of a node to a new address. May only be called by the current\n   * owner of the node.\n   * @param node The node to transfer ownership of.\n   * @param owner The address of the new owner.\n   */\n  function setOwner(bytes32 node, address owner) public only_owner(node) {\n      emit Transfer(node, owner);\n      records[node].owner = owner;\n  }\n\n  /**\n   * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\n   * called by the owner of the parent node.\n   * @param node The parent node.\n   * @param label The hash of the label specifying the subnode.\n   * @param owner The address of the new owner.\n   */\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public only_owner(node) {\n      bytes32 subnode = keccak256(abi.encodePacked(node, label));\n      emit NewOwner(node, label, owner);\n      records[subnode].owner = owner;\n  }\n\n  /**\n   * Sets the resolver address for the specified node.\n   * @param node The node to update.\n   * @param resolver The address of the resolver.\n   */\n  function setResolver(bytes32 node, address resolver) public only_owner(node) {\n      emit NewResolver(node, resolver);\n      records[node].resolver = resolver;\n  }\n\n  /**\n   * Sets the TTL for the specified node.\n   * @param node The node to update.\n   * @param ttl The TTL in seconds.\n   */\n  function setTTL(bytes32 node, uint64 ttl) public only_owner(node) {\n      emit NewTTL(node, ttl);\n      records[node].ttl = ttl;\n  }\n}"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled4.sol\":{\"content\":\"import \\\"github.com/ethereum/ens/contracts/ENS.sol\\\"; contract test7 {}\"},\"github.com/ethereum/ens/contracts/ENS.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\nimport './AbstractENS.sol';\\n\\n/**\\n * The ENS registry contract.\\n */\\ncontract ENS is AbstractENS {\\n  struct Record {\\n      address owner;\\n      address resolver;\\n      uint64 ttl;\\n  }\\n\\n  mapping(bytes32=>Record) records;\\n\\n  // Permits modifications only by the owner of the specified node.\\n  modifier only_owner(bytes32 node) {\\n      if (records[node].owner != msg.sender) revert();\\n      _;\\n  }\\n\\n  /**\\n   * Constructs a new ENS registrar.\\n   */\\n  constructor() public {\\n      records[0].owner = msg.sender;\\n  }\\n\\n  /**\\n   * Returns the address that owns the specified node.\\n   */\\n  function owner(bytes32 node) public view returns (address) {\\n      return records[node].owner;\\n  }\\n\\n  /**\\n   * Returns the address of the resolver for the specified node.\\n   */\\n  function resolver(bytes32 node) public view returns (address) {\\n      return records[node].resolver;\\n  }\\n\\n  /**\\n   * Returns the TTL of a node, and any records associated with it.\\n   */\\n  function ttl(bytes32 node) public view returns (uint64) {\\n      return records[node].ttl;\\n  }\\n\\n  /**\\n   * Transfers ownership of a node to a new address. May only be called by the current\\n   * owner of the node.\\n   * @param node The node to transfer ownership of.\\n   * @param owner The address of the new owner.\\n   */\\n  function setOwner(bytes32 node, address owner) public only_owner(node) {\\n      emit Transfer(node, owner);\\n      records[node].owner = owner;\\n  }\\n\\n  /**\\n   * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\\n   * called by the owner of the parent node.\\n   * @param node The parent node.\\n   * @param label The hash of the label specifying the subnode.\\n   * @param owner The address of the new owner.\\n   */\\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public only_owner(node) {\\n      bytes32 subnode = keccak256(abi.encodePacked(node, label));\\n      emit NewOwner(node, label, owner);\\n      records[subnode].owner = owner;\\n  }\\n\\n  /**\\n   * Sets the resolver address for the specified node.\\n   * @param node The node to update.\\n   * @param resolver The address of the resolver.\\n   */\\n  function setResolver(bytes32 node, address resolver) public only_owner(node) {\\n      emit NewResolver(node, resolver);\\n      records[node].resolver = resolver;\\n  }\\n\\n  /**\\n   * Sets the TTL for the specified node.\\n   * @param node The node to update.\\n   * @param ttl The TTL in seconds.\\n   */\\n  function setTTL(bytes32 node, uint64 ttl) public only_owner(node) {\\n      emit NewTTL(node, ttl);\\n      records[node].ttl = ttl;\\n  }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled4.sol\":{\"content\":\"import \\\"github.com/ethereum/ens/contracts/ENS.sol\\\"; contract test7 {}\"},\"github.com/ethereum/ens/contracts/ENS.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\nimport './AbstractENS.sol';\\n\\n/**\\n * The ENS registry contract.\\n */\\ncontract ENS is AbstractENS {\\n  struct Record {\\n      address owner;\\n      address resolver;\\n      uint64 ttl;\\n  }\\n\\n  mapping(bytes32=>Record) records;\\n\\n  // Permits modifications only by the owner of the specified node.\\n  modifier only_owner(bytes32 node) {\\n      if (records[node].owner != msg.sender) revert();\\n      _;\\n  }\\n\\n  /**\\n   * Constructs a new ENS registrar.\\n   */\\n  constructor() public {\\n      records[0].owner = msg.sender;\\n  }\\n\\n  /**\\n   * Returns the address that owns the specified node.\\n   */\\n  function owner(bytes32 node) public view returns (address) {\\n      return records[node].owner;\\n  }\\n\\n  /**\\n   * Returns the address of the resolver for the specified node.\\n   */\\n  function resolver(bytes32 node) public view returns (address) {\\n      return records[node].resolver;\\n  }\\n\\n  /**\\n   * Returns the TTL of a node, and any records associated with it.\\n   */\\n  function ttl(bytes32 node) public view returns (uint64) {\\n      return records[node].ttl;\\n  }\\n\\n  /**\\n   * Transfers ownership of a node to a new address. May only be called by the current\\n   * owner of the node.\\n   * @param node The node to transfer ownership of.\\n   * @param owner The address of the new owner.\\n   */\\n  function setOwner(bytes32 node, address owner) public only_owner(node) {\\n      emit Transfer(node, owner);\\n      records[node].owner = owner;\\n  }\\n\\n  /**\\n   * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\\n   * called by the owner of the parent node.\\n   * @param node The parent node.\\n   * @param label The hash of the label specifying the subnode.\\n   * @param owner The address of the new owner.\\n   */\\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public only_owner(node) {\\n      bytes32 subnode = keccak256(abi.encodePacked(node, label));\\n      emit NewOwner(node, label, owner);\\n      records[subnode].owner = owner;\\n  }\\n\\n  /**\\n   * Sets the resolver address for the specified node.\\n   * @param node The node to update.\\n   * @param resolver The address of the resolver.\\n   */\\n  function setResolver(bytes32 node, address resolver) public only_owner(node) {\\n      emit NewResolver(node, resolver);\\n      records[node].resolver = resolver;\\n  }\\n\\n  /**\\n   * Sets the TTL for the specified node.\\n   * @param node The node to update.\\n   * @param ttl The TTL in seconds.\\n   */\\n  function setTTL(bytes32 node, uint64 ttl) public only_owner(node) {\\n      emit NewTTL(node, ttl);\\n      records[node].ttl = ttl;\\n  }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled4.sol":{"content":"import \"github.com/ethereum/ens/contracts/ENS.sol\"; contract test7 {}"},"github.com/ethereum/ens/contracts/ENS.sol":{"content":"pragma solidity ^0.4.0;\n\nimport './AbstractENS.sol';\n\n/**\n * The ENS registry contract.\n */\ncontract ENS is AbstractENS {\n  struct Record {\n      address owner;\n      address resolver;\n      uint64 ttl;\n  }\n\n  mapping(bytes32=>Record) records;\n\n  // Permits modifications only by the owner of the specified node.\n  modifier only_owner(bytes32 node) {\n      if (records[node].owner != msg.sender) revert();\n      _;\n  }\n\n  /**\n   * Constructs a new ENS registrar.\n   */\n  constructor() public {\n      records[0].owner = msg.sender;\n  }\n\n  /**\n   * Returns the address that owns the specified node.\n   */\n  function owner(bytes32 node) public view returns (address) {\n      return records[node].owner;\n  }\n\n  /**\n   * Returns the address of the resolver for the specified node.\n   */\n  function resolver(bytes32 node) public view returns (address) {\n      return records[node].resolver;\n  }\n\n  /**\n   * Returns the TTL of a node, and any records associated with it.\n   */\n  function ttl(bytes32 node) public view returns (uint64) {\n      return records[node].ttl;\n  }\n\n  /**\n   * Transfers ownership of a node to a new address. May only be called by the current\n   * owner of the node.\n   * @param node The node to transfer ownership of.\n   * @param owner The address of the new owner.\n   */\n  function setOwner(bytes32 node, address owner) public only_owner(node) {\n      emit Transfer(node, owner);\n      records[node].owner = owner;\n  }\n\n  /**\n   * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\n   * called by the owner of the parent node.\n   * @param node The parent node.\n   * @param label The hash of the label specifying the subnode.\n   * @param owner The address of the new owner.\n   */\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public only_owner(node) {\n      bytes32 subnode = keccak256(abi.encodePacked(node, label));\n      emit NewOwner(node, label, owner);\n      records[subnode].owner = owner;\n  }\n\n  /**\n   * Sets the resolver address for the specified node.\n   * @param node The node to update.\n   * @param resolver The address of the resolver.\n   */\n  function setResolver(bytes32 node, address resolver) public only_owner(node) {\n      emit NewResolver(node, resolver);\n      records[node].resolver = resolver;\n  }\n\n  /**\n   * Sets the TTL for the specified node.\n   * @param node The node to update.\n   * @param ttl The TTL in seconds.\n   */\n  function setTTL(bytes32 node, uint64 ttl) public only_owner(node) {\n      emit NewTTL(node, ttl);\n      records[node].ttl = ttl;\n  }\n}"}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled4.sol\":{\"content\":\"import \\\"github.com/ethereum/ens/contracts/ENS.sol\\\"; contract test7 {}\"},\"github.com/ethereum/ens/contracts/ENS.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\nimport './AbstractENS.sol';\\n\\n/**\\n * The ENS registry contract.\\n */\\ncontract ENS is AbstractENS {\\n  struct Record {\\n      address owner;\\n      address resolver;\\n      uint64 ttl;\\n  }\\n\\n  mapping(bytes32=>Record) records;\\n\\n  // Permits modifications only by the owner of the specified node.\\n  modifier only_owner(bytes32 node) {\\n      if (records[node].owner != msg.sender) revert();\\n      _;\\n  }\\n\\n  /**\\n   * Constructs a new ENS registrar.\\n   */\\n  constructor() public {\\n      records[0].owner = msg.sender;\\n  }\\n\\n  /**\\n   * Returns the address that owns the specified node.\\n   */\\n  function owner(bytes32 node) public view returns (address) {\\n      return records[node].owner;\\n  }\\n\\n  /**\\n   * Returns the address of the resolver for the specified node.\\n   */\\n  function resolver(bytes32 node) public view returns (address) {\\n      return records[node].resolver;\\n  }\\n\\n  /**\\n   * Returns the TTL of a node, and any records associated with it.\\n   */\\n  function ttl(bytes32 node) public view returns (uint64) {\\n      return records[node].ttl;\\n  }\\n\\n  /**\\n   * Transfers ownership of a node to a new address. May only be called by the current\\n   * owner of the node.\\n   * @param node The node to transfer ownership of.\\n   * @param owner The address of the new owner.\\n   */\\n  function setOwner(bytes32 node, address owner) public only_owner(node) {\\n      emit Transfer(node, owner);\\n      records[node].owner = owner;\\n  }\\n\\n  /**\\n   * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\\n   * called by the owner of the parent node.\\n   * @param node The parent node.\\n   * @param label The hash of the label specifying the subnode.\\n   * @param owner The address of the new owner.\\n   */\\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public only_owner(node) {\\n      bytes32 subnode = keccak256(abi.encodePacked(node, label));\\n      emit NewOwner(node, label, owner);\\n      records[subnode].owner = owner;\\n  }\\n\\n  /**\\n   * Sets the resolver address for the specified node.\\n   * @param node The node to update.\\n   * @param resolver The address of the resolver.\\n   */\\n  function setResolver(bytes32 node, address resolver) public only_owner(node) {\\n      emit NewResolver(node, resolver);\\n      records[node].resolver = resolver;\\n  }\\n\\n  /**\\n   * Sets the TTL for the specified node.\\n   * @param node The node to update.\\n   * @param ttl The TTL in seconds.\\n   */\\n  function setTTL(bytes32 node, uint64 ttl) public only_owner(node) {\\n      emit NewTTL(node, ttl);\\n      records[node].ttl = ttl;\\n  }\\n}\"},\"github.com/ethereum/ens/contracts/AbstractENS.sol\":{\"content\":\"\\ncontract AbstractENS {\\n    function owner(bytes32 node) public view returns(address);\\n    function resolver(bytes32 node) public view returns(address);\\n    function ttl(bytes32 node) public view returns(uint64);\\n    function setOwner(bytes32 node, address owner) public;\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public;\\n    function setResolver(bytes32 node, address resolver) public;\\n    function setTTL(bytes32 node, uint64 ttl) public;\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled4.sol\":{\"content\":\"import \\\"github.com/ethereum/ens/contracts/ENS.sol\\\"; contract test7 {}\"},\"github.com/ethereum/ens/contracts/ENS.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\nimport './AbstractENS.sol';\\n\\n/**\\n * The ENS registry contract.\\n */\\ncontract ENS is AbstractENS {\\n  struct Record {\\n      address owner;\\n      address resolver;\\n      uint64 ttl;\\n  }\\n\\n  mapping(bytes32=>Record) records;\\n\\n  // Permits modifications only by the owner of the specified node.\\n  modifier only_owner(bytes32 node) {\\n      if (records[node].owner != msg.sender) revert();\\n      _;\\n  }\\n\\n  /**\\n   * Constructs a new ENS registrar.\\n   */\\n  constructor() public {\\n      records[0].owner = msg.sender;\\n  }\\n\\n  /**\\n   * Returns the address that owns the specified node.\\n   */\\n  function owner(bytes32 node) public view returns (address) {\\n      return records[node].owner;\\n  }\\n\\n  /**\\n   * Returns the address of the resolver for the specified node.\\n   */\\n  function resolver(bytes32 node) public view returns (address) {\\n      return records[node].resolver;\\n  }\\n\\n  /**\\n   * Returns the TTL of a node, and any records associated with it.\\n   */\\n  function ttl(bytes32 node) public view returns (uint64) {\\n      return records[node].ttl;\\n  }\\n\\n  /**\\n   * Transfers ownership of a node to a new address. May only be called by the current\\n   * owner of the node.\\n   * @param node The node to transfer ownership of.\\n   * @param owner The address of the new owner.\\n   */\\n  function setOwner(bytes32 node, address owner) public only_owner(node) {\\n      emit Transfer(node, owner);\\n      records[node].owner = owner;\\n  }\\n\\n  /**\\n   * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\\n   * called by the owner of the parent node.\\n   * @param node The parent node.\\n   * @param label The hash of the label specifying the subnode.\\n   * @param owner The address of the new owner.\\n   */\\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public only_owner(node) {\\n      bytes32 subnode = keccak256(abi.encodePacked(node, label));\\n      emit NewOwner(node, label, owner);\\n      records[subnode].owner = owner;\\n  }\\n\\n  /**\\n   * Sets the resolver address for the specified node.\\n   * @param node The node to update.\\n   * @param resolver The address of the resolver.\\n   */\\n  function setResolver(bytes32 node, address resolver) public only_owner(node) {\\n      emit NewResolver(node, resolver);\\n      records[node].resolver = resolver;\\n  }\\n\\n  /**\\n   * Sets the TTL for the specified node.\\n   * @param node The node to update.\\n   * @param ttl The TTL in seconds.\\n   */\\n  function setTTL(bytes32 node, uint64 ttl) public only_owner(node) {\\n      emit NewTTL(node, ttl);\\n      records[node].ttl = ttl;\\n  }\\n}\"},\"github.com/ethereum/ens/contracts/AbstractENS.sol\":{\"content\":\"\\ncontract AbstractENS {\\n    function owner(bytes32 node) public view returns(address);\\n    function resolver(bytes32 node) public view returns(address);\\n    function ttl(bytes32 node) public view returns(uint64);\\n    function setOwner(bytes32 node, address owner) public;\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public;\\n    function setResolver(bytes32 node, address resolver) public;\\n    function setTTL(bytes32 node, uint64 ttl) public;\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled4.sol":{"content":"import \"github.com/ethereum/ens/contracts/ENS.sol\"; contract test7 {}"},"github.com/ethereum/ens/contracts/ENS.sol":{"content":"pragma solidity ^0.4.0;\n\nimport './AbstractENS.sol';\n\n/**\n * The ENS registry contract.\n */\ncontract ENS is AbstractENS {\n  struct Record {\n      address owner;\n      address resolver;\n      uint64 ttl;\n  }\n\n  mapping(bytes32=>Record) records;\n\n  // Permits modifications only by the owner of the specified node.\n  modifier only_owner(bytes32 node) {\n      if (records[node].owner != msg.sender) revert();\n      _;\n  }\n\n  /**\n   * Constructs a new ENS registrar.\n   */\n  constructor() public {\n      records[0].owner = msg.sender;\n  }\n\n  /**\n   * Returns the address that owns the specified node.\n   */\n  function owner(bytes32 node) public view returns (address) {\n      return records[node].owner;\n  }\n\n  /**\n   * Returns the address of the resolver for the specified node.\n   */\n  function resolver(bytes32 node) public view returns (address) {\n      return records[node].resolver;\n  }\n\n  /**\n   * Returns the TTL of a node, and any records associated with it.\n   */\n  function ttl(bytes32 node) public view returns (uint64) {\n      return records[node].ttl;\n  }\n\n  /**\n   * Transfers ownership of a node to a new address. May only be called by the current\n   * owner of the node.\n   * @param node The node to transfer ownership of.\n   * @param owner The address of the new owner.\n   */\n  function setOwner(bytes32 node, address owner) public only_owner(node) {\n      emit Transfer(node, owner);\n      records[node].owner = owner;\n  }\n\n  /**\n   * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\n   * called by the owner of the parent node.\n   * @param node The parent node.\n   * @param label The hash of the label specifying the subnode.\n   * @param owner The address of the new owner.\n   */\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public only_owner(node) {\n      bytes32 subnode = keccak256(abi.encodePacked(node, label));\n      emit NewOwner(node, label, owner);\n      records[subnode].owner = owner;\n  }\n\n  /**\n   * Sets the resolver address for the specified node.\n   * @param node The node to update.\n   * @param resolver The address of the resolver.\n   */\n  function setResolver(bytes32 node, address resolver) public only_owner(node) {\n      emit NewResolver(node, resolver);\n      records[node].resolver = resolver;\n  }\n\n  /**\n   * Sets the TTL for the specified node.\n   * @param node The node to update.\n   * @param ttl The TTL in seconds.\n   */\n  function setTTL(bytes32 node, uint64 ttl) public only_owner(node) {\n      emit NewTTL(node, ttl);\n      records[node].ttl = ttl;\n  }\n}"},"github.com/ethereum/ens/contracts/AbstractENS.sol":{"content":"\ncontract AbstractENS {\n    function owner(bytes32 node) public view returns(address);\n    function resolver(bytes32 node) public view returns(address);\n    function ttl(bytes32 node) public view returns(uint64);\n    function setOwner(bytes32 node, address owner) public;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public;\n    function setResolver(bytes32 node, address resolver) public;\n    function setTTL(bytes32 node, uint64 ttl) public;\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n}"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled4.sol\":{\"content\":\"import \\\"github.com/ethereum/ens/contracts/ENS.sol\\\"; contract test7 {}\"},\"github.com/ethereum/ens/contracts/ENS.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\nimport './AbstractENS.sol';\\n\\n/**\\n * The ENS registry contract.\\n */\\ncontract ENS is AbstractENS {\\n  struct Record {\\n      address owner;\\n      address resolver;\\n      uint64 ttl;\\n  }\\n\\n  mapping(bytes32=>Record) records;\\n\\n  // Permits modifications only by the owner of the specified node.\\n  modifier only_owner(bytes32 node) {\\n      if (records[node].owner != msg.sender) revert();\\n      _;\\n  }\\n\\n  /**\\n   * Constructs a new ENS registrar.\\n   */\\n  constructor() public {\\n      records[0].owner = msg.sender;\\n  }\\n\\n  /**\\n   * Returns the address that owns the specified node.\\n   */\\n  function owner(bytes32 node) public view returns (address) {\\n      return records[node].owner;\\n  }\\n\\n  /**\\n   * Returns the address of the resolver for the specified node.\\n   */\\n  function resolver(bytes32 node) public view returns (address) {\\n      return records[node].resolver;\\n  }\\n\\n  /**\\n   * Returns the TTL of a node, and any records associated with it.\\n   */\\n  function ttl(bytes32 node) public view returns (uint64) {\\n      return records[node].ttl;\\n  }\\n\\n  /**\\n   * Transfers ownership of a node to a new address. May only be called by the current\\n   * owner of the node.\\n   * @param node The node to transfer ownership of.\\n   * @param owner The address of the new owner.\\n   */\\n  function setOwner(bytes32 node, address owner) public only_owner(node) {\\n      emit Transfer(node, owner);\\n      records[node].owner = owner;\\n  }\\n\\n  /**\\n   * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\\n   * called by the owner of the parent node.\\n   * @param node The parent node.\\n   * @param label The hash of the label specifying the subnode.\\n   * @param owner The address of the new owner.\\n   */\\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public only_owner(node) {\\n      bytes32 subnode = keccak256(abi.encodePacked(node, label));\\n      emit NewOwner(node, label, owner);\\n      records[subnode].owner = owner;\\n  }\\n\\n  /**\\n   * Sets the resolver address for the specified node.\\n   * @param node The node to update.\\n   * @param resolver The address of the resolver.\\n   */\\n  function setResolver(bytes32 node, address resolver) public only_owner(node) {\\n      emit NewResolver(node, resolver);\\n      records[node].resolver = resolver;\\n  }\\n\\n  /**\\n   * Sets the TTL for the specified node.\\n   * @param node The node to update.\\n   * @param ttl The TTL in seconds.\\n   */\\n  function setTTL(bytes32 node, uint64 ttl) public only_owner(node) {\\n      emit NewTTL(node, ttl);\\n      records[node].ttl = ttl;\\n  }\\n}\"},\"github.com/ethereum/ens/contracts/AbstractENS.sol\":{\"content\":\"\\ncontract AbstractENS {\\n    function owner(bytes32 node) public view returns(address);\\n    function resolver(bytes32 node) public view returns(address);\\n    function ttl(bytes32 node) public view returns(uint64);\\n    function setOwner(bytes32 node, address owner) public;\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public;\\n    function setResolver(bytes32 node, address resolver) public;\\n    function setTTL(bytes32 node, uint64 ttl) public;\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled4.sol\":{\"content\":\"import \\\"github.com/ethereum/ens/contracts/ENS.sol\\\"; contract test7 {}\"},\"github.com/ethereum/ens/contracts/ENS.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\nimport './AbstractENS.sol';\\n\\n/**\\n * The ENS registry contract.\\n */\\ncontract ENS is AbstractENS {\\n  struct Record {\\n      address owner;\\n      address resolver;\\n      uint64 ttl;\\n  }\\n\\n  mapping(bytes32=>Record) records;\\n\\n  // Permits modifications only by the owner of the specified node.\\n  modifier only_owner(bytes32 node) {\\n      if (records[node].owner != msg.sender) revert();\\n      _;\\n  }\\n\\n  /**\\n   * Constructs a new ENS registrar.\\n   */\\n  constructor() public {\\n      records[0].owner = msg.sender;\\n  }\\n\\n  /**\\n   * Returns the address that owns the specified node.\\n   */\\n  function owner(bytes32 node) public view returns (address) {\\n      return records[node].owner;\\n  }\\n\\n  /**\\n   * Returns the address of the resolver for the specified node.\\n   */\\n  function resolver(bytes32 node) public view returns (address) {\\n      return records[node].resolver;\\n  }\\n\\n  /**\\n   * Returns the TTL of a node, and any records associated with it.\\n   */\\n  function ttl(bytes32 node) public view returns (uint64) {\\n      return records[node].ttl;\\n  }\\n\\n  /**\\n   * Transfers ownership of a node to a new address. May only be called by the current\\n   * owner of the node.\\n   * @param node The node to transfer ownership of.\\n   * @param owner The address of the new owner.\\n   */\\n  function setOwner(bytes32 node, address owner) public only_owner(node) {\\n      emit Transfer(node, owner);\\n      records[node].owner = owner;\\n  }\\n\\n  /**\\n   * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\\n   * called by the owner of the parent node.\\n   * @param node The parent node.\\n   * @param label The hash of the label specifying the subnode.\\n   * @param owner The address of the new owner.\\n   */\\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public only_owner(node) {\\n      bytes32 subnode = keccak256(abi.encodePacked(node, label));\\n      emit NewOwner(node, label, owner);\\n      records[subnode].owner = owner;\\n  }\\n\\n  /**\\n   * Sets the resolver address for the specified node.\\n   * @param node The node to update.\\n   * @param resolver The address of the resolver.\\n   */\\n  function setResolver(bytes32 node, address resolver) public only_owner(node) {\\n      emit NewResolver(node, resolver);\\n      records[node].resolver = resolver;\\n  }\\n\\n  /**\\n   * Sets the TTL for the specified node.\\n   * @param node The node to update.\\n   * @param ttl The TTL in seconds.\\n   */\\n  function setTTL(bytes32 node, uint64 ttl) public only_owner(node) {\\n      emit NewTTL(node, ttl);\\n      records[node].ttl = ttl;\\n  }\\n}\"},\"github.com/ethereum/ens/contracts/AbstractENS.sol\":{\"content\":\"\\ncontract AbstractENS {\\n    function owner(bytes32 node) public view returns(address);\\n    function resolver(bytes32 node) public view returns(address);\\n    function ttl(bytes32 node) public view returns(uint64);\\n    function setOwner(bytes32 node, address owner) public;\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public;\\n    function setResolver(bytes32 node, address resolver) public;\\n    function setTTL(bytes32 node, uint64 ttl) public;\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled4.sol":{"content":"import \"github.com/ethereum/ens/contracts/ENS.sol\"; contract test7 {}"},"github.com/ethereum/ens/contracts/ENS.sol":{"content":"pragma solidity ^0.4.0;\n\nimport './AbstractENS.sol';\n\n/**\n * The ENS registry contract.\n */\ncontract ENS is AbstractENS {\n  struct Record {\n      address owner;\n      address resolver;\n      uint64 ttl;\n  }\n\n  mapping(bytes32=>Record) records;\n\n  // Permits modifications only by the owner of the specified node.\n  modifier only_owner(bytes32 node) {\n      if (records[node].owner != msg.sender) revert();\n      _;\n  }\n\n  /**\n   * Constructs a new ENS registrar.\n   */\n  constructor() public {\n      records[0].owner = msg.sender;\n  }\n\n  /**\n   * Returns the address that owns the specified node.\n   */\n  function owner(bytes32 node) public view returns (address) {\n      return records[node].owner;\n  }\n\n  /**\n   * Returns the address of the resolver for the specified node.\n   */\n  function resolver(bytes32 node) public view returns (address) {\n      return records[node].resolver;\n  }\n\n  /**\n   * Returns the TTL of a node, and any records associated with it.\n   */\n  function ttl(bytes32 node) public view returns (uint64) {\n      return records[node].ttl;\n  }\n\n  /**\n   * Transfers ownership of a node to a new address. May only be called by the current\n   * owner of the node.\n   * @param node The node to transfer ownership of.\n   * @param owner The address of the new owner.\n   */\n  function setOwner(bytes32 node, address owner) public only_owner(node) {\n      emit Transfer(node, owner);\n      records[node].owner = owner;\n  }\n\n  /**\n   * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\n   * called by the owner of the parent node.\n   * @param node The parent node.\n   * @param label The hash of the label specifying the subnode.\n   * @param owner The address of the new owner.\n   */\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public only_owner(node) {\n      bytes32 subnode = keccak256(abi.encodePacked(node, label));\n      emit NewOwner(node, label, owner);\n      records[subnode].owner = owner;\n  }\n\n  /**\n   * Sets the resolver address for the specified node.\n   * @param node The node to update.\n   * @param resolver The address of the resolver.\n   */\n  function setResolver(bytes32 node, address resolver) public only_owner(node) {\n      emit NewResolver(node, resolver);\n      records[node].resolver = resolver;\n  }\n\n  /**\n   * Sets the TTL for the specified node.\n   * @param node The node to update.\n   * @param ttl The TTL in seconds.\n   */\n  function setTTL(bytes32 node, uint64 ttl) public only_owner(node) {\n      emit NewTTL(node, ttl);\n      records[node].ttl = ttl;\n  }\n}"},"github.com/ethereum/ens/contracts/AbstractENS.sol":{"content":"\ncontract AbstractENS {\n    function owner(bytes32 node) public view returns(address);\n    function resolver(bytes32 node) public view returns(address);\n    function ttl(bytes32 node) public view returns(uint64);\n    function setOwner(bytes32 node, address owner) public;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public;\n    function setResolver(bytes32 node, address resolver) public;\n    function setTTL(bytes32 node, uint64 ttl) public;\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n}"}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/receiveAndFallback.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          receive() payable external{}\\n          fallback() external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/receiveAndFallback.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          receive() payable external{}\\n          fallback() external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/receiveAndFallback.sol":{"content":"\n        contract CheckSpecials {\n          receive() payable external{}\n          fallback() external {}\n        }\n      "}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/receiveAndFallback.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          receive() payable external{}\\n          fallback() external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/receiveAndFallback.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          receive() payable external{}\\n          fallback() external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/receiveAndFallback.sol":{"content":"\n        contract CheckSpecials {\n          receive() payable external{}\n          fallback() external {}\n        }\n      "}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/receiveOnly.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          receive() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/receiveOnly.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          receive() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/receiveOnly.sol":{"content":"\n        contract CheckSpecials {\n          receive() payable external {}\n        }\n      "}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/receiveOnly.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          receive() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/receiveOnly.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          receive() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/receiveOnly.sol":{"content":"\n        contract CheckSpecials {\n          receive() payable external {}\n        }\n      "}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/fallbackOnlyPayable.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          fallback() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/fallbackOnlyPayable.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          fallback() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/fallbackOnlyPayable.sol":{"content":"\n        contract CheckSpecials {\n          fallback() payable external {}\n        }\n      "}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/fallbackOnlyPayable.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          fallback() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/fallbackOnlyPayable.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          fallback() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/fallbackOnlyPayable.sol":{"content":"\n        contract CheckSpecials {\n          fallback() payable external {}\n        }\n      "}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/fallbackOnlyNotPayable.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          fallback() external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/fallbackOnlyNotPayable.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          fallback() external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/fallbackOnlyNotPayable.sol":{"content":"\n        contract CheckSpecials {\n          fallback() external {}\n        }\n      "}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/fallbackOnlyNotPayable.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          fallback() external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/fallbackOnlyNotPayable.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          fallback() external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/fallbackOnlyNotPayable.sol":{"content":"\n        contract CheckSpecials {\n          fallback() external {}\n        }\n      "}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/receiveAndFallbackBothPayable.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          receive() payable external {}\\n          fallback() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/receiveAndFallbackBothPayable.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          receive() payable external {}\\n          fallback() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/receiveAndFallbackBothPayable.sol":{"content":"\n        contract CheckSpecials {\n          receive() payable external {}\n          fallback() payable external {}\n        }\n      "}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/receiveAndFallbackBothPayable.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          receive() payable external {}\\n          fallback() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/receiveAndFallbackBothPayable.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          receive() payable external {}\\n          fallback() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/receiveAndFallbackBothPayable.sol":{"content":"\n        contract CheckSpecials {\n          receive() payable external {}\n          fallback() payable external {}\n        }\n      "}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/notSpecial.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          function otherFallback() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/notSpecial.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          function otherFallback() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/notSpecial.sol":{"content":"\n        contract CheckSpecials {\n          function otherFallback() payable external {}\n        }\n      "}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/notSpecial.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          function otherFallback() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/notSpecial.sol\":{\"content\":\"\\n        contract CheckSpecials {\\n          function otherFallback() payable external {}\\n        }\\n      \"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/notSpecial.sol":{"content":"\n        contract CheckSpecials {\n          function otherFallback() payable external {}\n        }\n      "}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"\\npragma solidity >=0.4.22 <0.6.0;\\ncontract test1 { address test = tx.origin; }\\ncontract test2 {}\\ncontract TooMuchGas {\\n  uint x;\\n  function() external { \\n      x++;\\n    uint test;\\n    uint test1;\\n  }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"\\npragma solidity >=0.4.22 <0.6.0;\\ncontract test1 { address test = tx.origin; }\\ncontract test2 {}\\ncontract TooMuchGas {\\n  uint x;\\n  function() external { \\n      x++;\\n    uint test;\\n    uint test1;\\n  }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled.sol":{"content":"\npragma solidity >=0.4.22 <0.6.0;\ncontract test1 { address test = tx.origin; }\ncontract test2 {}\ncontract TooMuchGas {\n  uint x;\n  function() external { \n      x++;\n    uint test;\n    uint test1;\n  }\n}"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"\\npragma solidity >=0.4.22 <0.6.0;\\ncontract test1 { address test = tx.origin; }\\ncontract test2 {}\\ncontract TooMuchGas {\\n  uint x;\\n  function() external { \\n      x++;\\n    uint test;\\n    uint test1;\\n  }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"\\npragma solidity >=0.4.22 <0.6.0;\\ncontract test1 { address test = tx.origin; }\\ncontract test2 {}\\ncontract TooMuchGas {\\n  uint x;\\n  function() external { \\n      x++;\\n    uint test;\\n    uint test1;\\n  }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled.sol":{"content":"\npragma solidity >=0.4.22 <0.6.0;\ncontract test1 { address test = tx.origin; }\ncontract test2 {}\ncontract TooMuchGas {\n  uint x;\n  function() external { \n      x++;\n    uint test;\n    uint test1;\n  }\n}"}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"\\n      contract TestContract { function f() public returns (uint) { return 8; }\\n      function g() public returns (uint, string memory, bool, uint) {\\n        uint payment = 345;\\n        bool payed = true;\\n        string memory comment = \\\"comment_comment_\\\";\\n        uint month = 4;\\n        return (payment, comment, payed, month); } }\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"\\n      contract TestContract { function f() public returns (uint) { return 8; }\\n      function g() public returns (uint, string memory, bool, uint) {\\n        uint payment = 345;\\n        bool payed = true;\\n        string memory comment = \\\"comment_comment_\\\";\\n        uint month = 4;\\n        return (payment, comment, payed, month); } }\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled.sol":{"content":"\n      contract TestContract { function f() public returns (uint) { return 8; }\n      function g() public returns (uint, string memory, bool, uint) {\n        uint payment = 345;\n        bool payed = true;\n        string memory comment = \"comment_comment_\";\n        uint month = 4;\n        return (payment, comment, payed, month); } }"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"\\n      contract TestContract { function f() public returns (uint) { return 8; }\\n      function g() public returns (uint, string memory, bool, uint) {\\n        uint payment = 345;\\n        bool payed = true;\\n        string memory comment = \\\"comment_comment_\\\";\\n        uint month = 4;\\n        return (payment, comment, payed, month); } }\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/Untitled.sol\":{\"content\":\"\\n      contract TestContract { function f() public returns (uint) { return 8; }\\n      function g() public returns (uint, string memory, bool, uint) {\\n        uint payment = 345;\\n        bool payed = true;\\n        string memory comment = \\\"comment_comment_\\\";\\n        uint month = 4;\\n        return (payment, comment, payed, month); } }\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/Untitled.sol":{"content":"\n      contract TestContract { function f() public returns (uint) { return 8; }\n      function g() public returns (uint, string memory, bool, uint) {\n        uint payment = 345;\n        bool payed = true;\n        string memory comment = \"comment_comment_\";\n        uint month = 4;\n        return (payment, comment, payed, month); } }"}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/returnValues.sol\":{\"content\":\"\\n  contract testReturnValues {\\n    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\\n    function retunValues1 () public returns (bool _b, uint _u, int _i, address _a)  {\\n        _b = true;\\n        _u = 345;\\n        _i = -345;\\n        _a = msg.sender;\\n    }\\n\\n    function retunValues2 () public returns (byte _b, bytes2 _b2, bytes3 _b3, bytes memory _blit, bytes5 _b5, bytes6 _b6, string memory _str, bytes7 _b7, bytes22 _b22, bytes32 _b32)  {\\n        _b = 0x12;\\n        _b2 = 0x1223;\\n        _b5 = hex\\\"043245\\\";\\n        _b6 = hex\\\"2345532532\\\";\\n        _b7 = hex\\\"03252353253253\\\";\\n        _b22 = hex\\\"325235235325325325235325\\\";\\n        _b32 = hex\\\"032523532532523532523532523532\\\";\\n        _blit = hex\\\"123498\\\";\\n        _str = \\\"this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string\\\";\\n    }\\n\\n    function retunValues3 () public returns (ActionChoices _en, int[5][] memory _a1)  {\\n       _en = ActionChoices.GoStraight;\\n       int[5][] memory a = new int[5][](3);\\n       a[0] = [int(1),-45,-78,56,60];\\n       a[1] = [int(-1),42,334,-45455,-446];\\n       a[2] = [int(1),10,-5435,45,-7];\\n      _a1 = a;\\n    }\\n  }\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/returnValues.sol\":{\"content\":\"\\n  contract testReturnValues {\\n    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\\n    function retunValues1 () public returns (bool _b, uint _u, int _i, address _a)  {\\n        _b = true;\\n        _u = 345;\\n        _i = -345;\\n        _a = msg.sender;\\n    }\\n\\n    function retunValues2 () public returns (byte _b, bytes2 _b2, bytes3 _b3, bytes memory _blit, bytes5 _b5, bytes6 _b6, string memory _str, bytes7 _b7, bytes22 _b22, bytes32 _b32)  {\\n        _b = 0x12;\\n        _b2 = 0x1223;\\n        _b5 = hex\\\"043245\\\";\\n        _b6 = hex\\\"2345532532\\\";\\n        _b7 = hex\\\"03252353253253\\\";\\n        _b22 = hex\\\"325235235325325325235325\\\";\\n        _b32 = hex\\\"032523532532523532523532523532\\\";\\n        _blit = hex\\\"123498\\\";\\n        _str = \\\"this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string\\\";\\n    }\\n\\n    function retunValues3 () public returns (ActionChoices _en, int[5][] memory _a1)  {\\n       _en = ActionChoices.GoStraight;\\n       int[5][] memory a = new int[5][](3);\\n       a[0] = [int(1),-45,-78,56,60];\\n       a[1] = [int(-1),42,334,-45455,-446];\\n       a[2] = [int(1),10,-5435,45,-7];\\n      _a1 = a;\\n    }\\n  }\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/returnValues.sol":{"content":"\n  contract testReturnValues {\n    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\n    function retunValues1 () public returns (bool _b, uint _u, int _i, address _a)  {\n        _b = true;\n        _u = 345;\n        _i = -345;\n        _a = msg.sender;\n    }\n\n    function retunValues2 () public returns (byte _b, bytes2 _b2, bytes3 _b3, bytes memory _blit, bytes5 _b5, bytes6 _b6, string memory _str, bytes7 _b7, bytes22 _b22, bytes32 _b32)  {\n        _b = 0x12;\n        _b2 = 0x1223;\n        _b5 = hex\"043245\";\n        _b6 = hex\"2345532532\";\n        _b7 = hex\"03252353253253\";\n        _b22 = hex\"325235235325325325235325\";\n        _b32 = hex\"032523532532523532523532523532\";\n        _blit = hex\"123498\";\n        _str = \"this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string\";\n    }\n\n    function retunValues3 () public returns (ActionChoices _en, int[5][] memory _a1)  {\n       _en = ActionChoices.GoStraight;\n       int[5][] memory a = new int[5][](3);\n       a[0] = [int(1),-45,-78,56,60];\n       a[1] = [int(-1),42,334,-45455,-446];\n       a[2] = [int(1),10,-5435,45,-7];\n      _a1 = a;\n    }\n  }"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/returnValues.sol\":{\"content\":\"\\n  contract testReturnValues {\\n    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\\n    function retunValues1 () public returns (bool _b, uint _u, int _i, address _a)  {\\n        _b = true;\\n        _u = 345;\\n        _i = -345;\\n        _a = msg.sender;\\n    }\\n\\n    function retunValues2 () public returns (byte _b, bytes2 _b2, bytes3 _b3, bytes memory _blit, bytes5 _b5, bytes6 _b6, string memory _str, bytes7 _b7, bytes22 _b22, bytes32 _b32)  {\\n        _b = 0x12;\\n        _b2 = 0x1223;\\n        _b5 = hex\\\"043245\\\";\\n        _b6 = hex\\\"2345532532\\\";\\n        _b7 = hex\\\"03252353253253\\\";\\n        _b22 = hex\\\"325235235325325325235325\\\";\\n        _b32 = hex\\\"032523532532523532523532523532\\\";\\n        _blit = hex\\\"123498\\\";\\n        _str = \\\"this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string\\\";\\n    }\\n\\n    function retunValues3 () public returns (ActionChoices _en, int[5][] memory _a1)  {\\n       _en = ActionChoices.GoStraight;\\n       int[5][] memory a = new int[5][](3);\\n       a[0] = [int(1),-45,-78,56,60];\\n       a[1] = [int(-1),42,334,-45455,-446];\\n       a[2] = [int(1),10,-5435,45,-7];\\n      _a1 = a;\\n    }\\n  }\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/returnValues.sol\":{\"content\":\"\\n  contract testReturnValues {\\n    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\\n    function retunValues1 () public returns (bool _b, uint _u, int _i, address _a)  {\\n        _b = true;\\n        _u = 345;\\n        _i = -345;\\n        _a = msg.sender;\\n    }\\n\\n    function retunValues2 () public returns (byte _b, bytes2 _b2, bytes3 _b3, bytes memory _blit, bytes5 _b5, bytes6 _b6, string memory _str, bytes7 _b7, bytes22 _b22, bytes32 _b32)  {\\n        _b = 0x12;\\n        _b2 = 0x1223;\\n        _b5 = hex\\\"043245\\\";\\n        _b6 = hex\\\"2345532532\\\";\\n        _b7 = hex\\\"03252353253253\\\";\\n        _b22 = hex\\\"325235235325325325235325\\\";\\n        _b32 = hex\\\"032523532532523532523532523532\\\";\\n        _blit = hex\\\"123498\\\";\\n        _str = \\\"this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string\\\";\\n    }\\n\\n    function retunValues3 () public returns (ActionChoices _en, int[5][] memory _a1)  {\\n       _en = ActionChoices.GoStraight;\\n       int[5][] memory a = new int[5][](3);\\n       a[0] = [int(1),-45,-78,56,60];\\n       a[1] = [int(-1),42,334,-45455,-446];\\n       a[2] = [int(1),10,-5435,45,-7];\\n      _a1 = a;\\n    }\\n  }\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/returnValues.sol":{"content":"\n  contract testReturnValues {\n    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\n    function retunValues1 () public returns (bool _b, uint _u, int _i, address _a)  {\n        _b = true;\n        _u = 345;\n        _i = -345;\n        _a = msg.sender;\n    }\n\n    function retunValues2 () public returns (byte _b, bytes2 _b2, bytes3 _b3, bytes memory _blit, bytes5 _b5, bytes6 _b6, string memory _str, bytes7 _b7, bytes22 _b22, bytes32 _b32)  {\n        _b = 0x12;\n        _b2 = 0x1223;\n        _b5 = hex\"043245\";\n        _b6 = hex\"2345532532\";\n        _b7 = hex\"03252353253253\";\n        _b22 = hex\"325235235325325325235325\";\n        _b32 = hex\"032523532532523532523532523532\";\n        _blit = hex\"123498\";\n        _str = \"this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string _ this is a long string\";\n    }\n\n    function retunValues3 () public returns (ActionChoices _en, int[5][] memory _a1)  {\n       _en = ActionChoices.GoStraight;\n       int[5][] memory a = new int[5][](3);\n       a[0] = [int(1),-45,-78,56,60];\n       a[1] = [int(-1),42,334,-45455,-446];\n       a[2] = [int(1),10,-5435,45,-7];\n      _a1 = a;\n    }\n  }"}},"optimization":false,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/inputValues.sol\":{\"content\":\"\\n  contract test {\\n    event event1(int _i, uint indexed _u, string indexed _str, bytes4 _b, string _notIndexed);\\n    function inputValue1 (uint _u, int _i, string memory _str) public returns (uint _uret, int _iret, string memory _strret) {\\n      _uret = _u;\\n      _iret = _i;\\n      _strret = _str;\\n    }\\n    function inputValue2 (uint[3] memory _n, bytes8[4] memory _b8) public returns (uint[3] memory _nret, bytes8[4] memory _b8ret){\\n        _nret = _n;\\n        _b8ret = _b8;\\n        emit event1(-123, 123, \\\"test\\\", hex\\\"1234\\\", \\\"test _ test _ test _ test test _ test test _ test test _ test test _ test test _ test test _ test \\\");\\n    }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/inputValues.sol\":{\"content\":\"\\n  contract test {\\n    event event1(int _i, uint indexed _u, string indexed _str, bytes4 _b, string _notIndexed);\\n    function inputValue1 (uint _u, int _i, string memory _str) public returns (uint _uret, int _iret, string memory _strret) {\\n      _uret = _u;\\n      _iret = _i;\\n      _strret = _str;\\n    }\\n    function inputValue2 (uint[3] memory _n, bytes8[4] memory _b8) public returns (uint[3] memory _nret, bytes8[4] memory _b8ret){\\n        _nret = _n;\\n        _b8ret = _b8;\\n        emit event1(-123, 123, \\\"test\\\", hex\\\"1234\\\", \\\"test _ test _ test _ test test _ test test _ test test _ test test _ test test _ test test _ test \\\");\\n    }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":true,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/inputValues.sol":{"content":"\n  contract test {\n    event event1(int _i, uint indexed _u, string indexed _str, bytes4 _b, string _notIndexed);\n    function inputValue1 (uint _u, int _i, string memory _str) public returns (uint _uret, int _iret, string memory _strret) {\n      _uret = _u;\n      _iret = _i;\n      _strret = _str;\n    }\n    function inputValue2 (uint[3] memory _n, bytes8[4] memory _b8) public returns (uint[3] memory _nret, bytes8[4] memory _b8ret){\n        _nret = _n;\n        _b8ret = _b8;\n        emit event1(-123, 123, \"test\", hex\"1234\", \"test _ test _ test _ test test _ test test _ test test _ test test _ test test _ test test _ test \");\n    }\n}"}},"optimization":true,"missingInputs":[]},"{\"language\":\"Solidity\",\"sources\":{\"browser/inputValues.sol\":{\"content\":\"\\n  contract test {\\n    event event1(int _i, uint indexed _u, string indexed _str, bytes4 _b, string _notIndexed);\\n    function inputValue1 (uint _u, int _i, string memory _str) public returns (uint _uret, int _iret, string memory _strret) {\\n      _uret = _u;\\n      _iret = _i;\\n      _strret = _str;\\n    }\\n    function inputValue2 (uint[3] memory _n, bytes8[4] memory _b8) public returns (uint[3] memory _nret, bytes8[4] memory _b8ret){\\n        _nret = _n;\\n        _b8ret = _b8;\\n        emit event1(-123, 123, \\\"test\\\", hex\\\"1234\\\", \\\"test _ test _ test _ test test _ test test _ test test _ test test _ test test _ test test _ test \\\");\\n    }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}":{"key":"{\"language\":\"Solidity\",\"sources\":{\"browser/inputValues.sol\":{\"content\":\"\\n  contract test {\\n    event event1(int _i, uint indexed _u, string indexed _str, bytes4 _b, string _notIndexed);\\n    function inputValue1 (uint _u, int _i, string memory _str) public returns (uint _uret, int _iret, string memory _strret) {\\n      _uret = _u;\\n      _iret = _i;\\n      _strret = _str;\\n    }\\n    function inputValue2 (uint[3] memory _n, bytes8[4] memory _b8) public returns (uint[3] memory _nret, bytes8[4] memory _b8ret){\\n        _nret = _n;\\n        _b8ret = _b8;\\n        emit event1(-123, 123, \\\"test\\\", hex\\\"1234\\\", \\\"test _ test _ test _ test test _ test test _ test test _ test test _ test test _ test test _ test \\\");\\n    }\\n}\"}},\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200},\"outputSelection\":{\"*\":{\"\":[\"legacyAST\",\"ast\"],\"*\":[\"abi\",\"metadata\",\"devdoc\",\"userdoc\",\"evm.legacyAssembly\",\"evm.bytecode\",\"evm.deployedBytecode\",\"evm.methodIdentifiers\",\"evm.gasEstimates\"]}}}}","source":{"browser/inputValues.sol":{"content":"\n  contract test {\n    event event1(int _i, uint indexed _u, string indexed _str, bytes4 _b, string _notIndexed);\n    function inputValue1 (uint _u, int _i, string memory _str) public returns (uint _uret, int _iret, string memory _strret) {\n      _uret = _u;\n      _iret = _i;\n      _strret = _str;\n    }\n    function inputValue2 (uint[3] memory _n, bytes8[4] memory _b8) public returns (uint[3] memory _nret, bytes8[4] memory _b8ret){\n        _nret = _n;\n        _b8ret = _b8;\n        emit event1(-123, 123, \"test\", hex\"1234\", \"test _ test _ test _ test test _ test test _ test test _ test test _ test test _ test test _ test \");\n    }\n}"}},"optimization":false,"missingInputs":[]}};
